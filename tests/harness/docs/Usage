Components In Flexus:
	Flexus automatically creates a class for every component. Component "X" will have the class named as "XComponent".
	Along with component class, there are 2 important structures which decide the behaviours of a component:
		1. "XConfiguration_struct" is used to specify the parameters of a component (e.g., the number of cycles a memory request takes in MemoryLoopback is set by cfg.Delay)
		2. "XJumpTable" is used to register the callback functions used by the component to send AND receive data. See more in the section "Dynamic Ports".
	All these structures are generated automatically by the boost pre-processor.
	An example of one such elaborated component is "MemoryLoopbackExpanded.cpp" which contains the pre-processed MemoryLoopback component. 	

Harness File Structure:
	1. "harness_base" contains 2 files:
		a. "all_tests.cpp": the main testing file for google test
		b. "wiring.cpp": the wiring for a trivial simulator with no components. This is needed to create a dummy core. This just provided the necessary function definitions to the linker so that the testing_harness executable can be generated.
	2. "docs" contains files describing the testing harness' usage.
	3. "tests" contains the actual tests.

Tests File Structure:
	Each test must have an independent test subdirectory under "tests". The name of this subdirectory can be anything.
	Each test's subdirectory contains:
		a. The source files for that particular test.
		b. If the component being tested has external dependencies on other components, then these must be specified in "extra_deps.cmake"
      - as an example, see the tests for MemoryLoopback
	It is crucial that two distinct test subdirectories don't test a common component. This will lead to multiple definition of component structures.
	If multiple tests are required for a component, they must be specified in the same subdirectory and in the same .cpp (post-preprocessing) file.
	This .cpp file will include the component implementation .cpp file as a header.
	if multiple files include the component implementation file, the compiler will complain about multiple definitions.
	To see an example of how multiple tests can be spread across different files, look at ExampleComponentTest.

extra_deps.cmake Structure:
	This cmake file has 2 variables:
		1. REQUIRED_COMPONENTS: This includes a list of all component names on which the component under test depends.
		2. ENABLE_TEST: If set to YES, the test will be enabled. If set to NO, the test is disabled.
	"extra_deps.cmake" is optional. If the test subdirectory doesn't have this file, the following default values are used:
		1. REQUIRED_COMPONENTS: "" i.e. empty list
		2. ENABLE_TEST: YES

Writing Tests:
	1. The component implementation file must be included. Implementation files for components are available in the respective component sources in flexus.
	   This file defines the component structures, namely, the Configuration_struct, the JumpTable, and the component class.
	2. <gtest/gtest.h> must be included for gtest support.
	3. The Configuration_struct and JumpTable must be created and passed as constructor arguments to the component constructor.

Interacting with components:
	1. Configuration_struct: This structure specifies the initial parameters of the component. The parameters can be accessed directly as they are members of this struct.
	2. JumpTable: This class is used to register callbacks to receive data from the component. Callback functions come in pairs of available and manipulate functions. These can be registered by setting up the function pointers wire_available_<port_name> and wire_manip_<port_name> in the JumpTable.
	4. Drive: Each component object has a drive(XInterface::<drive_name>) method which is used to drive the component.
	5. Misc: Other custom methods may be defined for a component. These methods can be called simply by using the component object.
	An example of such interactions can be found in ExampleComponentTest which interacts with the Dummy component.
	Roughly speaking, JumpTable is used when the component initiates the transfer (via PushOutput and PullInput ports) to register the callback functions.
	On the other hand, the Interface is used when the component is expected to fulfill a transfer request (via PushInput and PullOutput ports) by declaring the appropriate functions, which must be implemented by the component.

Dynamic Ports:
	Dynamic ports are different from standard ports in two ways:
		1. PushInput and PullOutput ports take an extra argument for the index on the component side.
		2. All dynamic ports must implement a width() function, which can be generated by using the FLEXUS_PORT_ARRAY_WIDTH macro.

All types of ports:
	1. Standard ports:
		a. PushOutput:
			Data flow direction: Component to Testing Harness
			Transfer Initiator: Component
			Component side usage: FLEXUS_CHANNEL(port_name) << payload;
			Testing harness usage: Must declare and register two functions:
						a. bool available(Flexus::Core::index_t)
						b. void manipulate(Flexus::Core::index_t, PayloadType &)
		b. PushInput:
			Data flow direction: Testing Harness to Component
			Transfer Initiator:Testing Harness 
			Component side usage: Must declare and register two functions:
						a. bool available(XComponentInterface::<port_name> const &)
						b. void push(XComponentInterface::<port_name> const &, PayloadType &)
			Testing harness usage: Call the appropriate member functions.
		
		c. PullOutput:
			Data flow direction: Component to Testing harness
			Transfer Initiator: Testing harness
			Component side usage: Must declare and register two functions:
						a. bool available(XComponentInterface::<port_name> const &)
						b. PayloadType pull(XComponentInterface::<port_name> const &)
			Testing harness side usage: Call the appropriate member functions.

		d. PullInput:
			Data flow direction: Testing harness to Component
			Transfer Initiator: Component
			Component side usage: FLEXUS_CHANNEL(port_name) >> payload;
			Testing harness side usage: Must declare and register two functions:
						a. bool available(Flexus::Core::index_t)
						b. void manipulate(Flexus::Core::index_t, Payload &)
	2. Dynamic ports 
		a. PushOutput:
			Data flow direction: Component to Testing harness
			Transfer Initiator: Component
			Component side usage: FLEXUS_CHANNEL_ARRAY(port_name, index) << payload;
			Testing harness side usage: Must declare and register two functions:
						a. bool available(Flexus::Core::index_t)
						b. void manipulate(Flexus::Core::index_t, PayloadType &)
		b. PushInput:
			Data flow direction: Testing harness to Component
			Transfer Initiator: Testing harness
			Component side usage: Must declare and register two functions:
						a. bool available(XComponentInterface::<port_name> const &, Flexus::Core:index_t)
						b. void push(XComponentInterface::<port_name> const &, Flexus::Core::index_t, PayloadType &)
			Testing harness side usage: Call the appropiate member functions.
		
		c. PullOutput:
			Data flow direction: Component to Testing harness
			Transfer Initiator: Testing harness
			Component side usage: Must declare and register two functions:
						a. bool available(XComponentInterface::<port_name> const &, Flexus::Core:index_t)
						b. PayloadType pull(XComponentInterface::<port_name> const &, Flexus::Core::index_t)
			Testing harness side usage: Call the appropriate member functions.

		d. PullInput:
			Data flow direction: Testing harness to Component
			Transfer Initiator: Component
			Component side usage: FLEXUS_CHANNEL_ARRAY(port_name, index) >> payload;
			Testing harness side usage: Must declare and register two functions:
						a. bool available(Flexus::Core::index_t)
						b. void manipulate(Flexus::Core::index_t, Payload &)

Test Fixtures:
	Google tests allows users to create test fixtures which can be used to reduce code duplication.
	A test fixture is a class which publicly inherits testing::Test. This class can overload 4 functions:
	1. void SetUpTestCase()		: This function is called once before all tests in the fixture are executed.
	2. void TearDownTestCase()	: This function is called once after all tests in the fixture are executed.
	3. void SetUp()			: This function is called once for each tests case, before it is run.
	4. void TearDown()		: This function is called once for each tests case, after it is run.
	Moreover, member variables can be defined in the test fixture class which are accessible to the test directly.

How to generate preprocessed files:
	Use the following command:
	g++ -std=c++11 -E -C -P -DSELECTED_DEBUG=None -DTARGET_PLATFORM=arm -DBOOST_MPL_LIMIT_VECTOR_SIZE=50 -I. -I/path/to/boost/include/dir path/to/componentImpl.cpp > output.cpp

	Explanation of arguments to g++:
	-std		to specify the c++ standard
	-E 		to stop after pre-processing
	-C 		to not discard comments
	-P 		to inhibit line marker generation
	-Dxxx=yyy 	to define a macro xxx as the value yyy
	-I/some_path 	to add /some_path to the include path
	
	What happens this command is executed
	The pre-processor of a compiler is responsible for resolving macros and handling #include statements. In C/C++, #include<some_file> instructs the pre-processor to replace the #include statement with the contents of "some_file". Since "some_file" itself might have some #include statements, this replacement is done recursively. As a result, the output of the pre-processor is a very large file. The command given above is instructs g++ to stop after the pre-processing step. Since this command generates a very large file, it is useful to know that since the #include statements are replace in-place, the pre-processed code of the componentImpl.cpp file can be found at the near the bottom of the output file. "preprocessing.png" in this directory gives a pictorial description of this process.
