Components In Flexus:
	Flexus automatically creates a class for every component. Component "X" will have the class named as "XComponent".
	Along with component class, there are 2 important structures which decide the behaviours of a component:
		1. "XConfiguration_struct" is used to specify the parameters of a component (e.g., the number of cycles a memory request takes in MemoryLoopback is set by cfg.Delay)
		2. "XJumpTable" is used to register the callback functions used by the component to send AND receive data. See more in the section "Dynamic Ports".
	All these structures are generated automatically by the boost pre-processor.
	An example of one such elaborated component is "MemoryLoopbackExpanded.cpp" which contains the pre-processed MemoryLoopback component. 	

Harness File Structure:
	1. "harness_base" contains 2 files:
		a. "all_tests.cpp": the main testing file for google test
		b. "wiring.cpp": the wiring for a trivial simulator with no components. This is needed to create a dummy core. This just provided the necessary function definitions to the linker so that the testing_harness executable can be generated.
	2. "docs" contains files describing the testing harness' usage.
	3. "tests" contains the actual tests.

Tests File Structure:
	Each test must have an independent test subdirectory under "tests". The name of this subdirectory can be anything.
	Each test's subdirectory contains:
		a. The source files for that particular test.
		b. If the component being tested has external dependencies on other components, then these must be specified in "extra_deps.cmake"
      - as an example, see the tests for MemoryLoopback
	It is crucial that two distinct test subdirectories don't test a common component. This will lead to multiple definition of component structures.
	If multiple tests are required for a component, they must be specified in the same subdirectory and in the same .cpp (post-preprocessing) file.
	This .cpp file will include the component implementation .cpp file as a header.
	if multiple files include the component implementation file, the compiler will complain about multiple definitions.
	To see an example of how multiple tests can be spread across different files, look at ExampleComponentTest.

extra_deps.cmake Structure:
	This cmake file has 2 variables:
		1. REQUIRED_COMPONENTS: This includes a list of all component names on which the component under test depends.
		2. ENABLE_TEST: If set to YES, the test will be enabled. If set to NO, the test is disabled.
	"extra_deps.cmake" is optional. If the test subdirectory doesn't have this file, the following default values are used:
		1. REQUIRED_COMPONENTS: "" i.e. empty list
		2. ENABLE_TEST: YES

Writing Tests:
	1. The component implementation file must be included. Implementation files for components are available in the respective component sources in flexus.
	   This file defines the component structures, namely, the Configuration_struct, the JumpTable, and the component class.
	2. <gtest/gtest.h> must be included for gtest support.
	3. The Configuration_struct and JumpTable must be created and passed as constructor arguments to the component constructor.

Interacting with components:
	1. Configuration_struct: This structure specifies the initial parameters of the component. The parameters can be accessed directly as they are members of this struct.
	2. JumpTable: This class is used to register callbacks to receive data from the component. Callback functions come in pairs of available and manipulate functions. These can be registered by setting up the function pointers wire_available_<port_name> and wire_manip_<port_name> in the JumpTable.
	4. Drive: Each component object has a drive(XInterface::<drive_name>) method which is used to drive the component.
	5. Misc: Other custom methods may be defined for a component. These methods can be called simply by using the component object.
	An example of such interactions can be found in ExampleComponentTest which interacts with the Dummy component.
	Roughly speaking, JumpTable is used when the component initiates the transfer (via PushOutput and PullInput ports) to register the callback functions.
	On the other hand, the Interface is used when the component is expected to fulfill a transfer request (via PushInput and PullOutput ports) by declaring the appropriate functions, which must be implemented by the component.

Dynamic Ports:
	Dynamic ports are different from standard ports in two ways:
		1. PushInput and PullOutput ports take an extra argument for the index on the component side.
		2. All dynamic ports must implement a width() function, which can be generated by using the FLEXUS_PORT_ARRAY_WIDTH macro.

All types of ports:
	1. Standard ports:
		a. PushOutput:
			Data flow direction: Component to Testing Harness
			Transfer Initiator: Component
			Component side usage: FLEXUS_CHANNEL(port_name) << payload;
			Testing harness usage: Must declare and register two functions:
						a. bool available(Flexus::Core::index_t)
						b. void manipulate(Flexus::Core::index_t, PayloadType &)
		b. PushInput:
			Data flow direction: Testing Harness to Component
			Transfer Initiator:Testing Harness 
			Component side usage: Must declare and register two functions:
						a. bool available(XComponentInterface::<port_name> const &)
						b. void push(XComponentInterface::<port_name> const &, PayloadType &)
			Testing harness usage: Call the appropriate member functions.
		
		c. PullOutput:
			Data flow direction: Component to Testing harness
			Transfer Initiator: Testing harness
			Component side usage: Must declare and register two functions:
						a. bool available(XComponentInterface::<port_name> const &)
						b. PayloadType pull(XComponentInterface::<port_name> const &)
			Testing harness side usage: Call the appropriate member functions.

		d. PullInput:
			Data flow direction: Testing harness to Component
			Transfer Initiator: Component
			Component side usage: FLEXUS_CHANNEL(port_name) >> payload;
			Testing harness side usage: Must declare and register two functions:
						a. bool available(Flexus::Core::index_t)
						b. void manipulate(Flexus::Core::index_t, Payload &)
	2. Dynamic ports 
		a. PushOutput:
			Data flow direction: Component to Testing harness
			Transfer Initiator: Component
			Component side usage: FLEXUS_CHANNEL_ARRAY(port_name, index) << payload;
			Testing harness side usage: Must declare and register two functions:
						a. bool available(Flexus::Core::index_t)
						b. void manipulate(Flexus::Core::index_t, PayloadType &)
		b. PushInput:
			Data flow direction: Testing harness to Component
			Transfer Initiator: Testing harness
			Component side usage: Must declare and register two functions:
						a. bool available(XComponentInterface::<port_name> const &, Flexus::Core:index_t)
						b. void push(XComponentInterface::<port_name> const &, Flexus::Core::index_t, PayloadType &)
			Testing harness side usage: Call the appropiate member functions.
		
		c. PullOutput:
			Data flow direction: Component to Testing harness
			Transfer Initiator: Testing harness
			Component side usage: Must declare and register two functions:
						a. bool available(XComponentInterface::<port_name> const &, Flexus::Core:index_t)
						b. PayloadType pull(XComponentInterface::<port_name> const &, Flexus::Core::index_t)
			Testing harness side usage: Call the appropriate member functions.

		d. PullInput:
			Data flow direction: Testing harness to Component
			Transfer Initiator: Component
			Component side usage: FLEXUS_CHANNEL_ARRAY(port_name, index) >> payload;
			Testing harness side usage: Must declare and register two functions:
						a. bool available(Flexus::Core::index_t)
						b. void manipulate(Flexus::Core::index_t, Payload &)

Test Fixtures:
	Google tests allows users to create test fixtures which can be used to reduce code duplication.
	A test fixture is a class which publicly inherits testing::Test. This class can overload 4 functions:
	1. void SetUpTestCase()		: This function is called once before all tests in the fixture are executed.
	2. void TearDownTestCase()	: This function is called once after all tests in the fixture are executed.
	3. void SetUp()			: This function is called once for each tests case, before it is run.
	4. void TearDown()		: This function is called once for each tests case, after it is run.
	Moreover, member variables can be defined in the test fixture class which are accessible to the test directly.

How to generate preprocessed files:
	Use the following command:
	g++ -std=c++11 -E -C -P -DSELECTED_DEBUG=None -DTARGET_PLATFORM=arm -DBOOST_MPL_LIMIT_VECTOR_SIZE=50 -I. -I/path/to/boost/include/dir path/to/componentImpl.cpp > output.cpp

	Explanation of arguments to g++:
	-std		to specify the c++ standard
	-E 		to stop after pre-processing
	-C 		to not discard comments
	-P 		to inhibit line marker generation
	-Dxxx=yyy 	to define a macro xxx as the value yyy
	-I/some_path 	to add /some_path to the include path
	
	What happens this command is executed
	The pre-processor of a compiler is responsible for resolving macros and handling #include statements. In C/C++, #include<some_file> instructs the pre-processor to replace the #include statement with the contents of "some_file". Since "some_file" itself might have some #include statements, this replacement is done recursively. As a result, the output of the pre-processor is a very large file. The command given above is instructs g++ to stop after the pre-processing step. Since this command generates a very large file, it is useful to know that since the #include statements are replace in-place, the pre-processed code of the componentImpl.cpp file can be found at the near the bottom of the output file. "preprocessing.png" in this directory gives a pictorial description of this process.

Some commonly used macros in Flexus:
	a. Macros used in header files:
		
		COMPONENT_PARAMETERS (Used on lines 54-58 in MemoryLoopback.hpp. Expaned to lines 10-126 in MemoryLoopbackExpanded.cpp):
		This creates the Configuration_struct for the component. A variable is created for each parameter passed to this macro. The type of this variable is inferred from the second argument of PARAMETER macro. Therefore, the parameters of the component can be configured by setting up these variables to appropriate values.
		An templated member function named "get" is also created for each parameter. This function can be used to query various attributes of a particular parameter such as name, description, etc. 
		Apart from this, another struct called Configuration is also generated which holds the instance of the Configuration_struct.
		
		COMPONENT_INTERFACE (Used on lines 60-64 in MemoryLoopback.hpp. Expaned to lines 130-206 in MemoryLoopbackExpanded.cpp):
		This creates the JumpTable and the and the Interface structures for the component.
		Trivial structures are created for each port in the Interface. This is done done because Flexus creates overloaded functions with the same name for different port. The first argument to these functions is an instance of these trivial structures. These overloaded functions are declared in the Interface.
		The JumpTable holds the function pointers to the callback functions for ports which are invoked by the component. Therefore, to interact with such port,the function pointers in the JumpTable can be set to appropriate values. The naming convention for these function pointers is as follows:
		manipulate: wire_manip_<PortName>
		available: wire_available_<PortName>
	
	b. Macros used in implementation files:
		
		FLEXUS_COMPONENT (Used on line 72 in MemoryLoopbackImpl.cpp. Expaned to line 233 in MemoryLoopbackExpanded.cpp):
		This gets expanded to the class name for the component class. It also handles inheritance from FlexusComponentBase.
		
		FLEXUS_COMPONENT_IMPL (Used on line 73 in MemoryLoopbackImpl.cpp. Expaned to lines 235-250 in MemoryLoopbackExpanded.cpp):
		This macro handles the typedefs and namespaces. This also generates a member function which returns the name of the component
		
		FLEXUS_COMPONENT_CONSTRUCTOR (Used on line 80 in MemoryLoopbackImpl.cpp. Expaned to lines 260-265 in MemoryLoopbackExpanded.cpp):
		This macros declared the component constructor.
		
		FLEXUS_PASS_CONSTRUCTOR_ARGS (Used on line 80 in MemoryLoopbackImpl.cpp. Expaned to lines 260-265 in MemoryLoopbackExpanded.cpp):
		This macro sets up the default constructor arguments which are the Configuration_struct, the JumpTable, the Index and the Width.
		
		FLEXUS_CHANNEL (Used on lines 251, 264, etc. in MemoryLoopbackImpl.cpp. Expaned to lines 563, 567, etc. in MemoryLoopbackExpanded.cpp):
		This macro expands to a call to the appropriate callback function defined in the JumpTable.
		
		FLEXUS_COMPONENT_INSTANTIATOR (Used on line 278 in MemoryLoopbackImpl.cpp. Expaned to lines 582-588 in MemoryLoopbackExpanded.cpp):
		This macro creates a defines the component instantiation function in in the component interface.
		
		FLEXUS_PORT_ARRAY_WIDTH (Used on lines 136, 140, etc. in DummyImpl.cpp. Expaned to lines 255-370 in DummyExpanded.cpp):
		Defines the "width" function which returns the port width for a dynamic port.
